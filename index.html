<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash - Full Web Clone</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #0a0a1a, #1a0a2a);
            color: #fff;
            font-family: 'Arial Black', Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        canvas {
            border: 3px solid #00ffff;
            border-radius: 10px;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.6);
            cursor: pointer;
            image-rendering: pixelated;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1000" height="600"></canvas>
    <div id="ui"></div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const ui = document.getElementById('ui');

        const WIDTH = 1000;
        const HEIGHT = 600;
        const GROUND = HEIGHT - 80;
        const GRAVITY = 0.8;
        const JUMP = -16;
        const SPEED = 7;
        const CUBE_SIZE = 50;

        // Skins
        const SKINS = [
            {fill: '#ff4444', glow: '#ff8888'},
            {fill: '#44ff44', glow: '#88ff88'},
            {fill: '#4444ff', glow: '#8888ff'},
            {fill: '#ffff44', glow: '#ffff88'},
            {fill: '#ff44ff', glow: '#ff88ff'},
            {fill: '#44ffff', glow: '#88ffff'}
        ];
        let skinIndex = 0;

        // Game state
        let state = 'menu'; // menu, skins, levels, custom, game, editor
        let currentLevel = 0;
        let isCustom = false;
        let scrollOffset = 0;
        let editorScroll = 0;
        let editorMode = 'spike'; // spike, block
        let blockHeight = 100;
        let customLevels = JSON.parse(localStorage.getItem('gdLevels')) || [];

        // Predefined levels - 5 challenging levels
        const LEVELS = [
            // Level 1: Intro
            [{type: 'spike', x: 800}, {type: 'block', x: 1200, h: 120}, {type: 'spike', x: 1600}],
            // Level 2: Double spikes
            [{type: 'spike', x: 600}, {type: 'spike', x: 700}, {type: 'block', x: 1000, h: 100}, {type: 'spike', x: 1400}, {type: 'spike', x: 1500}],
            // Level 3: Platforms
            [{type: 'block', x: 500, h: 80}, {type: 'spike', x: 800}, {type: 'block', x: 1100, h: 160}, {type: 'spike', x: 1500}, {type: 'spike', x: 1600}],
            // Level 4: Tight gaps
            [{type: 'spike', x: 500}, {type: 'spike', x: 600}, {type: 'block', x: 900, h: 80}, {type: 'spike', x: 1200}, {type: 'block', x: 1500, h: 140}, {type: 'spike', x: 1800}, {type: 'spike', x: 1900}],
            // Level 5: Boss level - very challenging
            [{type: 'block', x: 400, h: 80}, {type: 'spike', x: 700}, {type: 'spike', x: 800}, {type: 'block', x: 1100, h: 160}, {type: 'spike', x: 1400}, {type: 'spike', x: 1500}, {type: 'spike', x: 1600}, {type: 'block', x: 1800, h: 120}, {type: 'spike', x: 2200}, {type: 'spike', x: 2300}]
        ];

        // Player
        let player = {
            x: 150,
            y: GROUND - CUBE_SIZE,
            vy: 0,
            onGround: true
        };

        // Obstacles
        let obstacles = [];

        // Background elements
        let bgLines = [];
        for (let i = 0; i < 20; i++) {
            bgLines.push({x: i * 100, speed: 2 + i * 0.2});
        }
        let bgCube = {
            x: WIDTH / 2,
            y: GROUND - CUBE_SIZE,
            vy: 0,
            jumpTimer: 0
        };

        // Particles for effects
        let particles = [];

        function resetLevel() {
            player.x = 150;
            player.y = GROUND - CUBE_SIZE;
            player.vy = 0;
            player.onGround = true;
            scrollOffset = 0;
            const levelData = isCustom ? customLevels[currentLevel] : LEVELS[currentLevel];
            obstacles = levelData.map(obs => ({...obs}));
        }

        function jump() {
            if (player.onGround) {
                player.vy = JUMP;
                player.onGround = false;
                addParticles(player.x + CUBE_SIZE/2, player.y + CUBE_SIZE, '#fff', 15);
            }
        }

        function addParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: Math.random() * -5 - 2,
                    life: 40,
                    maxLife: 40,
                    color
                });
            }
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.4;
                p.life--;
                p.alpha = p.life / p.maxLife;
                return p.life > 0;
            });
        }

        function updatePlayer() {
            player.vy += GRAVITY;
            player.y += player.vy;

            if (player.y >= GROUND - CUBE_SIZE) {
                player.y = GROUND - CUBE_SIZE;
                player.vy = 0;
                player.onGround = true;
            }
        }

        function updateGame() {
            updatePlayer();
            scrollOffset += SPEED;
            updateParticles();

            // Update obstacles positions (virtual)
            // Collisions
            for (let obs of obstacles) {
                const screenX = obs.x - scrollOffset;
                if (screenX < -100) continue;
                if (screenX > WIDTH) continue;

                if (obs.type === 'spike') {
                    if (player.x + CUBE_SIZE > screenX && player.x < screenX + 60 &&
                        player.y + CUBE_SIZE > GROUND - 60) {
                        // Death
                        addParticles(player.x + CUBE_SIZE/2, player.y + CUBE_SIZE/2, '#ff4444', 30);
                        setTimeout(() => state = 'menu', 800);
                        return;
                    }
                } else if (obs.type === 'block') {
                    if (player.x + CUBE_SIZE > screenX && player.x < screenX + 80 &&
                        player.y + CUBE_SIZE > GROUND - obs.h &&
                        player.y + CUBE_SIZE < GROUND + 10 &&
                        player.vy >= 0) {
                        player.y = GROUND - obs.h - CUBE_SIZE;
                        player.vy = 0;
                        player.onGround = true;
                    }
                }
            }

            // Win condition
            const maxX = Math.max(...obstacles.map(o => o.x));
            if (scrollOffset > maxX + 400) {
                setTimeout(() => {
                    alert('Level Complete! ðŸŽ‰');
                    state = 'menu';
                }, 500);
            }
        }

        function drawRect(x, y, w, h, color, glow = false) {
            if (glow) {
                ctx.shadowColor = color;
                ctx.shadowBlur = 20;
            }
            ctx.fillStyle = color;
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0;
        }

        function drawSpike(x) {
            ctx.fillStyle = '#ff3366';
            ctx.shadowColor = '#ff6699';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(x, GROUND);
            ctx.lineTo(x + 30, GROUND - 60);
            ctx.lineTo(x + 60, GROUND);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawPlayer() {
            const skin = SKINS[skinIndex];
            const px = player.x - scrollOffset + 100; // Offset for centering
            drawRect(px, player.y, CUBE_SIZE, CUBE_SIZE, skin.fill, true);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.strokeRect(px + 4, player.y + 4, CUBE_SIZE - 8, CUBE_SIZE - 8);
        }

        function drawObstacles() {
            obstacles.forEach(obs => {
                const x = obs.x - scrollOffset + 100;
                if (x < -100 || x > WIDTH) return;
                if (obs.type === 'spike') {
                    drawSpike(x);
                } else {
                    drawRect(x, GROUND - obs.h, 80, obs.h, '#ff5544', true);
                }
            });
        }

        function drawBackground() {
            // Moving lines
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            bgLines.forEach(line => {
                line.x -= line.speed;
                if (line.x < -100) line.x = WIDTH;
                ctx.beginPath();
                ctx.moveTo(line.x, 0);
                ctx.lineTo(line.x, HEIGHT);
                ctx.stroke();
            });

            // Ground glow
            const grad = ctx.createLinearGradient(0, GROUND, 0, HEIGHT);
            grad.addColorStop(0, 'rgba(0,255,255,0.4)');
            grad.addColorStop(1, 'rgba(0,100,200,0.1)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, GROUND, WIDTH, HEIGHT - GROUND);
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 10;
                ctx.fillRect(p.x - scrollOffset + 100, p.y, 6, 6);
                ctx.restore();
            });
        }

        function drawUI() {
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Skin: ${skinIndex + 1}`, 20, 40);
            if (state === 'game') {
                ctx.fillText(`Progress: ${(scrollOffset / 2500 * 100).toFixed(0)}%`, 20, HEIGHT - 40);
            }
        }

        // Menu drawing
        function drawMenu() {
            drawBackground();

            // Jumping bg cube
            bgCube.jumpTimer++;
            bgCube.vy += GRAVITY * 0.7;
            bgCube.y += bgCube.vy;
            if (bgCube.y > GROUND - CUBE_SIZE) {
                bgCube.y = GROUND - CUBE_SIZE;
                bgCube.vy = 0;
                if (bgCube.jumpTimer > 100) {
                    bgCube.vy = JUMP * 1.2;
                    bgCube.jumpTimer = 0;
                }
            }
            drawRect(bgCube.x - CUBE_SIZE/2, bgCube.y, CUBE_SIZE, CUBE_SIZE, '#ffffff', true);

            // Title
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 30;
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('GEOMETRY DASH', WIDTH/2, 150);
            ctx.shadowBlur = 0;

            // Buttons
            const buttons = [
                {text: 'PLAY LEVELS', y: 280, cb: () => {state = 'levels'; isCustom = false;}},
                {text: 'CUSTOM LEVELS', y: 350, cb: () => {state = 'levels'; isCustom = true;}},
                {text: 'SKINS', y: 420, cb: () => state = 'skins'},
                {text: 'LEVEL EDITOR', y: 490, cb: () => {state = 'editor'; obstacles = []; editorScroll = 0;}},
            ];
            buttons.forEach((b, i) => {
                const by = b.y;
                ctx.fillStyle = 'rgba(0,255,255,0.2)';
                ctx.fillRect(WIDTH/2 - 200, by - 30, 400, 60);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.strokeRect(WIDTH/2 - 200, by - 30, 400, 60);
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(b.text, WIDTH/2, by + 10);
            });
            window.menuButtons = buttons;
        }

        function drawSkins() {
            drawBackground();
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SELECT SKIN', WIDTH/2, 150);

            SKINS.forEach((skin, i) => {
                const sx = 200 + (i % 3) * 250;
                const sy = 250 + Math.floor(i / 3) * 150;
                drawRect(sx, sy, 80, 80, skin.fill, true);
                if (i === skinIndex) {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 5;
                    ctx.strokeRect(sx - 5, sy - 5, 90, 90);
                }
            });

            // Back button
            ctx.fillStyle = 'rgba(0,255,255,0.2)';
            ctx.fillRect(WIDTH/2 - 120, 520, 240, 50);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(WIDTH/2 - 120, 520, 240, 50);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 36px Arial';
            ctx.fillText('BACK', WIDTH/2, 555);
            window.skinBackRect = {x: WIDTH/2 - 120, y: 520, w: 240, h: 50};
        }

        function drawLevels() {
            drawBackground();
            const levelsList = isCustom ? customLevels : LEVELS;
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(isCustom ? 'CUSTOM LEVELS' : 'SELECT LEVEL', WIDTH/2, 150);

            levelsList.slice(0, 8).forEach((_, i) => { // Max 8 shown
                const by = 250 + i * 60;
                ctx.fillStyle = 'rgba(0,255,255,0.15)';
                ctx.fillRect(WIDTH/2 - 180, by - 25, 360, 50);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(WIDTH/2 - 180, by - 25, 360, 50);
                ctx.fillStyle = '#00ffff';
                ctx.font = 'bold 32px Arial';
                ctx.fillText(`LEVEL ${i+1}`, WIDTH/2, by + 8);
            });

            // Back
            ctx.fillStyle = 'rgba(0,255,255,0.2)';
            ctx.fillRect(WIDTH/2 - 120, 520, 240, 50);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.strokeRect(WIDTH/2 - 120, 520, 240, 50);
            ctx.fillStyle = '#00ffff';
            ctx.font = 'bold 36px Arial';
            ctx.fillText('BACK', WIDTH/2, 555);
            window.levelsList = levelsList;
        }

        function drawEditor() {
            drawBackground();
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(0, GROUND, WIDTH, HEIGHT - GROUND);

            // Draw placed obstacles
            obstacles.forEach(obs => {
                const x = obs.x - editorScroll;
                if (x < -100 || x > WIDTH) return;
                if (obs.type === 'spike') drawSpike(x);
                else drawRect(x, GROUND - obs.h, 80, obs.h, '#ff5544');
            });

            // Instructions
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Mode: ${editorMode.toUpperCase()} | Height: ${blockHeight}px`, 20, 40);
            ctx.fillText('S=Spike B=Block +/- Height C=Clear ENTER=Save ARROWS=Scroll', 20, 70);
            ctx.textAlign = 'center';

            // Scroll indicator
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(WIDTH - 150, 20, 120, 20);
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(WIDTH - 150 + (editorScroll / 5000 * 120), 20, 10, 20);
        }

        function drawGame() {
            drawBackground();
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(0, GROUND, WIDTH, HEIGHT - GROUND);

            drawObstacles();
            drawPlayer();
            drawParticles();
            drawUI();
        }

        // Main render
        function render() {
            ctx.clearRect(0, 0, WIDTH, HEIGHT);
            switch (state) {
                case 'menu': drawMenu(); break;
                case 'skins': drawSkins(); break;
                case 'levels':
                case 'custom': drawLevels(); break;
                case 'game': drawGame(); break;
                case 'editor': drawEditor(); break;
            }
            requestAnimationFrame(render);
        }

        // Events
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (state === 'game') {
                jump();
            } else if (state === 'menu') {
                window.menuButtons?.forEach(b => {
                    if (x > WIDTH/2 - 200 && x < WIDTH/2 + 200 && y > b.y - 30 && y < b.y + 30) {
                        b.cb();
                    }
                });
            } else if (state === 'skins') {
                if (x > window.skinBackRect.x && x < window.skinBackRect.x + window.skinBackRect.w &&
                    y > window.skinBackRect.y && y < window.skinBackRect.y + window.skinBackRect.h) {
                    state = 'menu';
                }
                SKINS.forEach((_, i) => {
                    const sx = 200 + (i % 3) * 250;
                    const sy = 250 + Math.floor(i / 3) * 150;
                    if (x > sx && x < sx + 80 && y > sy && y < sy + 80) {
                        skinIndex = i;
                        state = 'menu';
                    }
                });
            } else if (state === 'levels' || state === 'custom') {
                const list = window.levelsList;
                list.forEach((_, i) => {
                    const by = 250 + i * 60;
                    if (y > by - 25 && y < by + 25 && list[i]) {
                        currentLevel = i;
                        resetLevel();
                        state = 'game';
                        isCustom = state === 'custom';
                    }
                });
                if (x > WIDTH/2 - 120 && x < WIDTH/2 + 120 && y > 520 && y < 570) {
                    state = 'menu';
                }
            } else if (state === 'editor') {
                const placeX = x + editorScroll;
                if (editorMode === 'spike') {
                    obstacles.push({type: 'spike', x: placeX});
                } else {
                    obstacles.push({type: 'block', x: placeX, h: blockHeight});
                }
            }
        });

        document.addEventListener('keydown', (e) => {
            if (state === 'game' && e.code === 'Space') {
                e.preventDefault();
                jump();
            } else if (state === 'editor') {
                e.preventDefault();
                if (e.key === 's' || e.key === 'S') editorMode = 'spike';
                if (e.key === 'b' || e.key === 'B') editorMode = 'block';
                if (e.key === 'ArrowUp') blockHeight = Math.min(300, blockHeight + 20);
                if (e.key === 'ArrowDown') blockHeight = Math.max(60, blockHeight - 20);
                if (e.key === 'c' || e.key === 'C') obstacles = [];
                if (e.key === 'Enter') {
                    if (obstacles.length > 5) { // Min obstacles
                        customLevels.push(obstacles.map(o => ({...o})));
                        localStorage.setItem('gdLevels', JSON.stringify(customLevels));
                        alert('Level saved!');
                    }
                    state = 'menu';
                }
                if (e.key === 'ArrowLeft') editorScroll = Math.max(0, editorScroll - 50);
                if (e.key === 'ArrowRight') editorScroll += 50;
            }
        });

        // Init
        resetLevel();
        render();
    </script>
</body>
</html>
