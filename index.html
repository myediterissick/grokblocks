import pygame
import sys
import json

# Initialize Pygame
pygame.init()

# Constants
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
GRAVITY = 0.5
JUMP_STRENGTH = -12
PLAYER_SIZE = 40
OBSTACLE_SIZE = 40
SPIKE_HEIGHT = 40
GROUND_HEIGHT = SCREEN_HEIGHT - 50
FPS = 60

# Colors
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
PURPLE = (128, 0, 128)

# Skins: list of colors for the player
SKINS = [RED, GREEN, BLUE, YELLOW, PURPLE]
SKIN_NAMES = ["Red", "Green", "Blue", "Yellow", "Purple"]

# Predefined levels: list of obstacles
# Each obstacle is a dict: {'type': 'block' or 'spike', 'x': position, 'height': for blocks}
LEVELS = [
    # Level 1: Easy
    [
        {'type': 'spike', 'x': 400},
        {'type': 'block', 'x': 600, 'height': 80},
        {'type': 'spike', 'x': 800},
    ],
    # Level 2: Medium
    [
        {'type': 'spike', 'x': 300},
        {'type': 'spike', 'x': 350},
        {'type': 'block', 'x': 500, 'height': 120},
        {'type': 'spike', 'x': 700},
        {'type': 'spike', 'x': 750},
    ],
    # Level 3: Harder
    [
        {'type': 'block', 'x': 200, 'height': 40},
        {'type': 'spike', 'x': 300},
        {'type': 'block', 'x': 400, 'height': 80},
        {'type': 'spike', 'x': 500},
        {'type': 'spike', 'x': 550},
        {'type': 'block', 'x': 700, 'height': 160},
    ],
    # Level 4: Challenging
    [
        {'type': 'spike', 'x': 250},
        {'type': 'spike', 'x': 300},
        {'type': 'block', 'x': 400, 'height': 40},
        {'type': 'spike', 'x': 500},
        {'type': 'block', 'x': 600, 'height': 80},
        {'type': 'spike', 'x': 700},
        {'type': 'spike', 'x': 750},
        {'type': 'spike', 'x': 800},
    ],
    # Level 5: Very Challenging
    [
        {'type': 'block', 'x': 150, 'height': 40},
        {'type': 'spike', 'x': 250},
        {'type': 'spike', 'x': 300},
        {'type': 'block', 'x': 400, 'height': 120},
        {'type': 'spike', 'x': 500},
        {'type': 'spike', 'x': 550},
        {'type': 'block', 'x': 650, 'height': 80},
        {'type': 'spike', 'x': 750},
        {'type': 'spike', 'x': 800},
        {'type': 'spike', 'x': 850},
    ]
]

# Custom levels file
CUSTOM_LEVELS_FILE = "custom_levels.json"
custom_levels = []

# Load custom levels if exist
try:
    with open(CUSTOM_LEVELS_FILE, 'r') as f:
        custom_levels = json.load(f)
except FileNotFoundError:
    pass

class Player:
    def __init__(self, skin_index=0):
        self.rect = pygame.Rect(100, GROUND_HEIGHT - PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE)
        self.velocity_y = 0
        self.is_jumping = False
        self.skin = SKINS[skin_index]

    def update(self):
        self.velocity_y += GRAVITY
        self.rect.y += self.velocity_y
        if self.rect.bottom >= GROUND_HEIGHT:
            self.rect.bottom = GROUND_HEIGHT
            self.velocity_y = 0
            self.is_jumping = False

    def jump(self):
        if not self.is_jumping:
            self.velocity_y = JUMP_STRENGTH
            self.is_jumping = True

    def draw(self, screen):
        pygame.draw.rect(screen, self.skin, self.rect)

class Obstacle:
    def __init__(self, obs_dict, scroll_x):
        self.type = obs_dict['type']
        self.x = obs_dict['x'] + scroll_x
        if self.type == 'block':
            self.height = obs_dict.get('height', OBSTACLE_SIZE)
            self.rect = pygame.Rect(self.x, GROUND_HEIGHT - self.height, OBSTACLE_SIZE, self.height)
        elif self.type == 'spike':
            self.rect = pygame.Rect(self.x, GROUND_HEIGHT - SPIKE_HEIGHT, OBSTACLE_SIZE, SPIKE_HEIGHT)

    def update(self, speed):
        self.x -= speed
        self.rect.x = self.x

    def draw(self, screen):
        if self.type == 'block':
            pygame.draw.rect(screen, RED, self.rect)
        elif self.type == 'spike':
            pygame.draw.polygon(screen, RED, [
                (self.x, GROUND_HEIGHT),
                (self.x + OBSTACLE_SIZE / 2, GROUND_HEIGHT - SPIKE_HEIGHT),
                (self.x + OBSTACLE_SIZE, GROUND_HEIGHT)
            ])

class Button:
    def __init__(self, x, y, width, height, text, color=BLUE, text_color=WHITE):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.text_color = text_color

    def draw(self, screen):
        pygame.draw.rect(screen, self.color, self.rect)
        font = pygame.font.SysFont(None, 36)
        text_surf = font.render(self.text, True, self.text_color)
        text_rect = text_surf.get_rect(center=self.rect.center)
        screen.blit(text_surf, text_rect)

    def is_clicked(self, pos):
        return self.rect.collidepoint(pos)

class Game:
    def __init__(self):
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("Geometry Dash Clone")
        self.clock = pygame.time.Clock()
        self.state = "menu"
        self.current_level = 0
        self.is_custom = False
        self.player = Player()
        self.obstacles = []
        self.scroll_x = 0
        self.speed = 5
        self.selected_skin = 0
        self.editor_obstacles = []
        self.editor_mode = "place_spike"  # or "place_block" or "set_height"
        self.editor_block_height = 40
        self.background_block = Player()
        self.background_block.rect.x = SCREEN_WIDTH // 2
        self.background_block.rect.y = GROUND_HEIGHT - PLAYER_SIZE
        self.bg_jump_timer = 0

    def reset_level(self):
        self.player = Player(self.selected_skin)
        self.obstacles = []
        self.scroll_x = 0
        level_data = custom_levels[self.current_level] if self.is_custom else LEVELS[self.current_level]
        for obs in level_data:
            self.obstacles.append(Obstacle(obs, self.scroll_x))

    def run(self):
        while True:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.save_custom_levels()
                    pygame.quit()
                    sys.exit()
                if event.type == pygame.MOUSEBUTTONDOWN:
                    if self.state == "menu":
                        self.handle_menu_click(event.pos)
                    elif self.state == "skins":
                        self.handle_skins_click(event.pos)
                    elif self.state == "levels":
                        self.handle_levels_click(event.pos)
                    elif self.state == "editor":
                        self.handle_editor_click(event.pos)
                if event.type == pygame.KEYDOWN:
                    if self.state == "game" and event.key == pygame.K_SPACE:
                        self.player.jump()
                    elif self.state == "editor":
                        if event.key == pygame.K_s:
                            self.editor_mode = "place_spike"
                        elif event.key == pygame.K_b:
                            self.editor_mode = "place_block"
                        elif event.key == pygame.K_UP:
                            self.editor_block_height += 40
                        elif event.key == pygame.K_DOWN:
                            self.editor_block_height = max(40, self.editor_block_height - 40)
                        elif event.key == pygame.K_c:
                            self.editor_obstacles.clear()
                        elif event.key == pygame.K_RETURN:
                            custom_levels.append(self.editor_obstacles[:])
                            self.save_custom_levels()
                            self.state = "menu"

            self.screen.fill(BLACK)

            if self.state == "menu":
                self.draw_menu()
            elif self.state == "skins":
                self.draw_skins()
            elif self.state == "levels":
                self.draw_levels()
            elif self.state == "game":
                self.update_game()
                self.draw_game()
            elif self.state == "editor":
                self.update_editor()
                self.draw_editor()

            pygame.display.flip()
            self.clock.tick(FPS)

    def draw_menu(self):
        self.update_background_animation()
        self.background_block.draw(self.screen)

        title_font = pygame.font.SysFont(None, 72)
        title = title_font.render("Geometry Dash Clone", True, WHITE)
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 100))

        play_button = Button(SCREEN_WIDTH // 2 - 100, 200, 200, 50, "Play Levels")
        create_button = Button(SCREEN_WIDTH // 2 - 100, 260, 200, 50, "Create Level")
        skins_button = Button(SCREEN_WIDTH // 2 - 100, 320, 200, 50, "Select Skin")
        custom_button = Button(SCREEN_WIDTH // 2 - 100, 380, 200, 50, "Custom Levels")
        quit_button = Button(SCREEN_WIDTH // 2 - 100, 440, 200, 50, "Quit")

        play_button.draw(self.screen)
        create_button.draw(self.screen)
        skins_button.draw(self.screen)
        custom_button.draw(self.screen)
        quit_button.draw(self.screen)

        self.menu_buttons = [play_button, create_button, skins_button, custom_button, quit_button]

    def handle_menu_click(self, pos):
        if self.menu_buttons[0].is_clicked(pos):  # Play
            self.state = "levels"
            self.is_custom = False
        elif self.menu_buttons[1].is_clicked(pos):  # Create
            self.state = "editor"
            self.editor_obstacles = []
        elif self.menu_buttons[2].is_clicked(pos):  # Skins
            self.state = "skins"
        elif self.menu_buttons[3].is_clicked(pos):  # Custom
            self.state = "levels"
            self.is_custom = True
        elif self.menu_buttons[4].is_clicked(pos):  # Quit
            self.save_custom_levels()
            pygame.quit()
            sys.exit()

    def draw_skins(self):
        title_font = pygame.font.SysFont(None, 72)
        title = title_font.render("Select Skin", True, WHITE)
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 100))

        self.skin_buttons = []
        for i, skin in enumerate(SKINS):
            button = Button(100 + i * 150, 200, 100, 50, SKIN_NAMES[i], skin)
            button.draw(self.screen)
            self.skin_buttons.append(button)

        back_button = Button(SCREEN_WIDTH // 2 - 100, 500, 200, 50, "Back")
        back_button.draw(self.screen)
        self.skin_buttons.append(back_button)

    def handle_skins_click(self, pos):
        for i, button in enumerate(self.skin_buttons[:-1]):
            if button.is_clicked(pos):
                self.selected_skin = i
                self.state = "menu"
                return
        if self.skin_buttons[-1].is_clicked(pos):  # Back
            self.state = "menu"

    def draw_levels(self):
        title_font = pygame.font.SysFont(None, 72)
        title = title_font.render("Select Level" if not self.is_custom else "Select Custom Level", True, WHITE)
        self.screen.blit(title, (SCREEN_WIDTH // 2 - title.get_width() // 2, 100))

        levels_data = custom_levels if self.is_custom else LEVELS
        self.level_buttons = []
        for i in range(len(levels_data)):
            button = Button(SCREEN_WIDTH // 2 - 100, 200 + i * 60, 200, 50, f"Level {i+1}")
            button.draw(self.screen)
            self.level_buttons.append(button)

        back_button = Button(SCREEN_WIDTH // 2 - 100, 200 + len(levels_data) * 60, 200, 50, "Back")
        back_button.draw(self.screen)
        self.level_buttons.append(back_button)

    def handle_levels_click(self, pos):
        for i, button in enumerate(self.level_buttons[:-1]):
            if button.is_clicked(pos):
                self.current_level = i
                self.reset_level()
                self.state = "game"
                return
        if self.level_buttons[-1].is_clicked(pos):  # Back
            self.state = "menu"

    def update_game(self):
        self.player.update()

        # Scroll
        self.scroll_x += self.speed
        for obs in self.obstacles:
            obs.update(self.speed)

        # Remove off-screen obstacles
        self.obstacles = [obs for obs in self.obstacles if obs.x > -OBSTACLE_SIZE]

        # Collision detection
        for obs in self.obstacles:
            if self.player.rect.colliderect(obs.rect):
                self.state = "menu"  # Die and back to menu
                return

        # Win condition: if scrolled far enough
        if self.scroll_x > max(obs['x'] for obs in (custom_levels if self.is_custom else LEVELS)[self.current_level]) + SCREEN_WIDTH:
            self.state = "menu"  # Win and back to menu

        # Jump on mouse click too
        if pygame.mouse.get_pressed()[0]:
            self.player.jump()

    def draw_game(self):
        self.player.draw(self.screen)
        for obs in self.obstacles:
            obs.draw(self.screen)

        # Draw ground
        pygame.draw.line(self.screen, WHITE, (0, GROUND_HEIGHT), (SCREEN_WIDTH, GROUND_HEIGHT), 5)

    def update_editor(self):
        mouse_pos = pygame.mouse.get_pos()
        if pygame.mouse.get_pressed()[0]:
            click_x = mouse_pos[0] + self.scroll_x  # Adjust for scroll if needed, but for editor, maybe no scroll
            if self.editor_mode == "place_spike":
                self.editor_obstacles.append({'type': 'spike', 'x': click_x})
            elif self.editor_mode == "place_block":
                self.editor_obstacles.append({'type': 'block', 'x': click_x, 'height': self.editor_block_height})

    def draw_editor(self):
        title_font = pygame.font.SysFont(None, 48)
        instructions = [
            "Editor: S - Spike, B - Block, UP/DOWN - Block Height",
            f"Current Mode: {self.editor_mode}, Block Height: {self.editor_block_height}",
            "C - Clear, ENTER - Save and Exit"
        ]
        for i, instr in enumerate(instructions):
            text = title_font.render(instr, True, WHITE)
            self.screen.blit(text, (20, 20 + i * 40))

        for obs_dict in self.editor_obstacles:
            obs = Obstacle(obs_dict, 0)  # No scroll in editor
            obs.draw(self.screen)

        # Draw ground
        pygame.draw.line(self.screen, WHITE, (0, GROUND_HEIGHT), (SCREEN_WIDTH, GROUND_HEIGHT), 5)

    def save_custom_levels(self):
        with open(CUSTOM_LEVELS_FILE, 'w') as f:
            json.dump(custom_levels, f)

    def update_background_animation(self):
        self.background_block.update()
        self.bg_jump_timer += 1
        if self.bg_jump_timer > 60:  # Jump every second
            self.background_block.jump()
            self.bg_jump_timer = 0

if __name__ == "__main__":
    game = Game()
    game.run()
